//go:build !tinygo && !js && !wasm

package fpdf

import (
	"bytes"
	"encoding/gob"
)

// GobEncode encodes the receiving image to a byte slice.
// Note: This method is only available when NOT compiling with TinyGo or for WASM.
// encoding/gob is not supported in TinyGo due to reflection limitations.
func (info *ImageInfoType) GobEncode() (buf []byte, err error) {
	fields := []any{info.data, info.smask, info.n, info.w, info.h, info.cs,
		info.pal, info.bpc, info.f, info.dp, info.trns, info.scale, info.dpi}
	w := new(bytes.Buffer)
	encoder := gob.NewEncoder(w)
	for j := 0; j < len(fields) && err == nil; j++ {
		err = encoder.Encode(fields[j])
	}
	if err == nil {
		buf = w.Bytes()
	}
	return
}

// GobDecode decodes the specified byte buffer (generated by GobEncode) into
// the receiving image.
// Note: This method is only available when NOT compiling with TinyGo or for WASM.
// encoding/gob is not supported in TinyGo due to reflection limitations.
func (info *ImageInfoType) GobDecode(buf []byte) (err error) {
	fields := []any{&info.data, &info.smask, &info.n, &info.w, &info.h,
		&info.cs, &info.pal, &info.bpc, &info.f, &info.dp, &info.trns, &info.scale, &info.dpi}
	r := bytes.NewBuffer(buf)
	decoder := gob.NewDecoder(r)
	for j := 0; j < len(fields) && err == nil; j++ {
		err = decoder.Decode(fields[j])
	}

	info.i, err = generateImageID(info)
	return
}
